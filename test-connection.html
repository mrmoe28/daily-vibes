<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskFlow Connection Test</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            line-height: 1.6;
        }
        .test-section {
            margin: 2rem 0;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .test-result {
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button {
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        .offline { background: #dc3545; }
        pre { background: #f8f9fa; padding: 1rem; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>TaskFlow Frontend-Backend Connection Test</h1>
    
    <div class="test-section">
        <h2>Backend Health Check</h2>
        <button onclick="testHealth()">Test Health Endpoint</button>
        <button onclick="testUserData()">Test User Data API</button>
        <button onclick="testTaskSync()">Test Task Sync</button>
        <div id="healthResults"></div>
    </div>

    <div class="test-section">
        <h2>Connection Status</h2>
        <p>Current Status: <span id="connectionStatus">Unknown</span></p>
        <button onclick="goOffline()">Simulate Offline</button>
        <button onclick="goOnline()">Simulate Online</button>
        <button onclick="testOfflineStorage()">Test Offline Storage</button>
        <div id="connectionResults"></div>
    </div>

    <div class="test-section">
        <h2>Data Persistence Test</h2>
        <button onclick="testLocalStorage()">Test localStorage</button>
        <button onclick="testBackendPersistence()">Test Backend Persistence</button>
        <button onclick="testDataSync()">Test Data Synchronization</button>
        <div id="persistenceResults"></div>
    </div>

    <div class="test-section">
        <h2>Error Handling Test</h2>
        <button onclick="testNetworkError()">Test Network Error</button>
        <button onclick="testTimeout()">Test Request Timeout</button>
        <button onclick="testRetryMechanism()">Test Retry Mechanism</button>
        <div id="errorResults"></div>
    </div>

    <script>
        const API_BASE = window.location.origin + '/api';
        const testUserId = 'test_' + Date.now();
        let isOfflineMode = false;

        // Utility functions
        function addResult(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const result = document.createElement('div');
            result.className = `test-result ${type}`;
            result.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
            container.appendChild(result);
            container.scrollTop = container.scrollHeight;
        }

        function updateConnectionStatus() {
            const status = document.getElementById('connectionStatus');
            if (isOfflineMode) {
                status.textContent = 'Offline (Simulated)';
                status.style.color = '#dc3545';
            } else if (navigator.onLine) {
                status.textContent = 'Online';
                status.style.color = '#28a745';
            } else {
                status.textContent = 'Offline';
                status.style.color = '#dc3545';
            }
        }

        // Health check tests
        async function testHealth() {
            try {
                const response = await fetch(`${API_BASE}/health`);
                const data = await response.json();
                addResult('healthResults', `Health check successful: ${JSON.stringify(data, null, 2)}`, 'success');
            } catch (error) {
                addResult('healthResults', `Health check failed: ${error.message}`, 'error');
            }
        }

        async function testUserData() {
            try {
                // Test storing data
                const storeResponse = await fetch(`${API_BASE}/user/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: testUserId,
                        key: 'test-data',
                        value: JSON.stringify({ timestamp: Date.now(), test: true })
                    })
                });
                
                if (!storeResponse.ok) throw new Error(`Store failed: ${storeResponse.status}`);
                
                // Test retrieving data
                const getResponse = await fetch(`${API_BASE}/user/data?userId=${testUserId}`);
                const data = await getResponse.json();
                
                if (data.success && data.data.length > 0) {
                    addResult('healthResults', `User data API working: Stored and retrieved data successfully`, 'success');
                } else {
                    addResult('healthResults', `User data API issue: ${JSON.stringify(data)}`, 'error');
                }
            } catch (error) {
                addResult('healthResults', `User data API failed: ${error.message}`, 'error');
            }
        }

        async function testTaskSync() {
            try {
                const testTasks = [
                    {
                        id: 'test_' + Date.now(),
                        title: 'Test Task',
                        description: 'Testing sync functionality',
                        priority: 'high',
                        category: 'test',
                        status: 'todo',
                        createdAt: new Date().toISOString()
                    }
                ];

                const response = await fetch(`${API_BASE}/user/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: testUserId,
                        key: 'tasks',
                        value: JSON.stringify(testTasks)
                    })
                });

                if (response.ok) {
                    addResult('healthResults', `Task sync successful: Saved ${testTasks.length} test tasks`, 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                addResult('healthResults', `Task sync failed: ${error.message}`, 'error');
            }
        }

        // Connection tests
        function goOffline() {
            isOfflineMode = true;
            updateConnectionStatus();
            addResult('connectionResults', 'Switched to offline mode (simulated)', 'info');
        }

        function goOnline() {
            isOfflineMode = false;
            updateConnectionStatus();
            addResult('connectionResults', 'Switched to online mode', 'info');
        }

        async function testOfflineStorage() {
            try {
                const testData = {
                    tasks: [
                        {
                            id: 'offline_' + Date.now(),
                            title: 'Offline Test Task',
                            status: 'todo',
                            createdAt: new Date().toISOString()
                        }
                    ],
                    timestamp: Date.now()
                };

                // Store in localStorage
                localStorage.setItem('test-offline-data', JSON.stringify(testData));
                
                // Verify storage
                const stored = JSON.parse(localStorage.getItem('test-offline-data'));
                
                if (stored && stored.tasks.length === 1) {
                    addResult('connectionResults', 'Offline storage working: Data saved and retrieved from localStorage', 'success');
                } else {
                    addResult('connectionResults', 'Offline storage failed: Could not verify stored data', 'error');
                }
            } catch (error) {
                addResult('connectionResults', `Offline storage error: ${error.message}`, 'error');
            }
        }

        // Persistence tests
        async function testLocalStorage() {
            try {
                const testKey = 'persistence-test-' + Date.now();
                const testValue = { test: true, timestamp: Date.now() };
                
                localStorage.setItem(testKey, JSON.stringify(testValue));
                const retrieved = JSON.parse(localStorage.getItem(testKey));
                
                if (retrieved && retrieved.test === true) {
                    addResult('persistenceResults', 'localStorage test passed: Data persisted correctly', 'success');
                    localStorage.removeItem(testKey); // Cleanup
                } else {
                    addResult('persistenceResults', 'localStorage test failed: Data not retrieved correctly', 'error');
                }
            } catch (error) {
                addResult('persistenceResults', `localStorage test error: ${error.message}`, 'error');
            }
        }

        async function testBackendPersistence() {
            if (isOfflineMode) {
                addResult('persistenceResults', 'Skipping backend persistence test (offline mode)', 'info');
                return;
            }

            try {
                const testData = {
                    test: 'backend-persistence',
                    timestamp: Date.now(),
                    tasks: []
                };

                // Store data
                await fetch(`${API_BASE}/user/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: testUserId + '_persistence',
                        key: 'persistence-test',
                        value: JSON.stringify(testData)
                    })
                });

                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 100));

                // Retrieve data
                const response = await fetch(`${API_BASE}/user/data?userId=${testUserId}_persistence`);
                const result = await response.json();
                
                if (result.success && result.data.length > 0) {
                    const stored = JSON.parse(result.data[0].value);
                    if (stored.test === 'backend-persistence') {
                        addResult('persistenceResults', 'Backend persistence test passed: Data stored and retrieved', 'success');
                    } else {
                        addResult('persistenceResults', 'Backend persistence test failed: Data corrupted', 'error');
                    }
                } else {
                    addResult('persistenceResults', 'Backend persistence test failed: No data found', 'error');
                }
            } catch (error) {
                addResult('persistenceResults', `Backend persistence test error: ${error.message}`, 'error');
            }
        }

        async function testDataSync() {
            try {
                // Simulate local changes
                const localTasks = [
                    { id: 'local_1', title: 'Local Task 1', status: 'todo', updatedAt: new Date().toISOString() }
                ];
                
                // Simulate backend changes  
                const backendTasks = [
                    { id: 'local_1', title: 'Local Task 1 Updated', status: 'progress', updatedAt: new Date(Date.now() + 1000).toISOString() },
                    { id: 'backend_1', title: 'Backend Task', status: 'completed', updatedAt: new Date().toISOString() }
                ];

                // Test merge logic (simulated)
                const merged = mergeTasks(localTasks, backendTasks);
                
                if (merged.length === 2 && merged[0].status === 'progress') {
                    addResult('persistenceResults', 'Data sync test passed: Newer backend data preferred in merge', 'success');
                } else {
                    addResult('persistenceResults', 'Data sync test failed: Merge logic incorrect', 'error');
                }
            } catch (error) {
                addResult('persistenceResults', `Data sync test error: ${error.message}`, 'error');
            }
        }

        function mergeTasks(local, backend) {
            const localMap = new Map(local.map(task => [task.id, task]));
            const merged = [];

            backend.forEach(backendTask => {
                const localTask = localMap.get(backendTask.id);
                if (!localTask || new Date(backendTask.updatedAt) > new Date(localTask.updatedAt)) {
                    merged.push(backendTask);
                } else {
                    merged.push(localTask);
                }
                localMap.delete(backendTask.id);
            });

            localMap.forEach(task => merged.push(task));
            return merged;
        }

        // Error handling tests
        async function testNetworkError() {
            try {
                // Try to reach a non-existent endpoint
                await fetch('http://localhost:9999/nonexistent');
            } catch (error) {
                addResult('errorResults', `Network error handled correctly: ${error.message}`, 'success');
            }
        }

        async function testTimeout() {
            try {
                const controller = new AbortController();
                setTimeout(() => controller.abort(), 100); // Very short timeout
                
                await fetch(`${API_BASE}/health`, {
                    signal: controller.signal
                });
                
                addResult('errorResults', 'Timeout test failed: Request should have timed out', 'error');
            } catch (error) {
                if (error.name === 'AbortError') {
                    addResult('errorResults', 'Timeout test passed: Request properly aborted', 'success');
                } else {
                    addResult('errorResults', `Timeout test error: ${error.message}`, 'error');
                }
            }
        }

        async function testRetryMechanism() {
            let attempts = 0;
            const maxRetries = 3;
            
            async function mockApiCall() {
                attempts++;
                if (attempts < maxRetries) {
                    throw new Error('Network error');
                }
                return { success: true };
            }

            try {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        await mockApiCall();
                        break;
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        addResult('errorResults', `Retry attempt ${i + 1} failed, retrying...`, 'info');
                    }
                }
                
                if (attempts === maxRetries) {
                    addResult('errorResults', `Retry mechanism test passed: Succeeded after ${attempts} attempts`, 'success');
                } else {
                    addResult('errorResults', 'Retry mechanism test failed: Unexpected behavior', 'error');
                }
            } catch (error) {
                addResult('errorResults', `Retry mechanism test failed: ${error.message}`, 'error');
            }
        }

        // Initialize
        updateConnectionStatus();
        window.addEventListener('online', updateConnectionStatus);
        window.addEventListener('offline', updateConnectionStatus);
        
        // Auto-run basic tests
        setTimeout(() => {
            addResult('healthResults', 'Running automatic connection tests...', 'info');
            testHealth();
        }, 500);
    </script>
</body>
</html>